#!/usr/bin/env bash

# shell options
#set -o xtrace
set -o pipefail
shopt -s lastpipe
shopt -s extglob

#set -o errexit
#set -o errtrace
shopt -s extdebug

#trap 'echo ERROR:$0:${LINENO} $BASH_COMMAND >&2' ERR

# constants
export SHELL=bash
MIN_FZF_VERSION=0.27.1
PROG=$(basename "$0")
SYSZ_VERSION=2.0.0-beta
DEBUG_FILE=sysz.$(date -Iminutes).debug
EXITCODE=0

# environment variables
SYSZ_HISTORY=${SYSZ_HISTORY:-${XDG_CACHE_HOME:-$HOME/.cache}/sysz/history}
case "$SYSZ_COLOR" in
[nN][oO] | [oO][fF][fF] | [fF][aA][lL][sS][eE] | 0)
  SYSZ_COLOR=0
  ;;
*)
  ncolors=$(tput colors)

  if [[ -n $ncolors && $ncolors -ge 8 ]]; then
    SYSZ_COLOR=1
  else
    SYSZ_COLOR=0
  fi
  ;;
esac

export SYSTEMD_COLORS=${SYSTEMD_COLORS:-$SYSZ_COLOR}

[[ $SYSZ_COLOR -eq 1 ]] && {
  # colors
  reset=$'\e[0m'
  red=$'\e[31m'
  green=$'\e[32m'
  yellow=$'\e[33m'
  blue=$'\e[34m'
  cyan=$'\e[36m'
  gray=$'\e[37m'
}

# global variables
declare VERBOSE
declare DEBUG
declare CMD
declare -a ARGS
declare -a MANAGERS
declare -a STATES
declare -a TYPES

# ordered assocative array helpers
# https://stackoverflow.com/a/72263994/334632
function __add {
  local var=$1
  local key=$2
  local val=$3
  declare -ga "${var}_ORDER"
  declare -gA "${var}_MAP"
  local -n map=${var}_MAP
  local -n order=${var}_ORDER
  order+=("$key")
  map["$key"]=$val
}

function __get {
  local var=$1
  local key=$2
  local -n tmp=${var}_MAP
  echo "${tmp[$key]}"
}

function __keys {
  local var=$1
  local -n tmp=${var}_ORDER
  for x in "${tmp[@]}"; do
    echo "$x"
  done
}

function __values {
  local var=$1
  # shellcheck disable=SC2178
  local -n map=${var}_MAP
  # shellcheck disable=SC2178
  local -n order=${var}_ORDER
  for k in "${order[@]}"; do
    echo -n "${map[$k]} "
  done
  echo
}

# help
readonly _sysz_title="sysz - interactive terminal UI for systemctl"
readonly _sysz_usage="$PROG [OPTS...] [CMD] [-- ARGS...]"

! read -r -d '' _sysz_description <<EOM
sudo is invoked automatically, if necessary.

If only one unit is chosen, available commands will be presented
based on the state of the unit (e.g. "start" only shows if unit is "active").
EOM

__add _sysz_opts "-u, --user" "Only show --user units [default]."
__add _sysz_opts "--sys, --system" "Only show --system units [default]."
__add _sysz_opts "-s STATE, --state STATE" "Only show units in STATE (repeatable)."
__add _sysz_opts "-t TYPE, --type TYPE" "Only show units of TYPE (repeatable)."
__add _sysz_opts "--no-color" "Disable colors."
__add _sysz_opts "-V, --verbose" "Print the systemctl command."
__add _sysz_opts "-v, --version" "Print the version."
__add _sysz_opts "-h, --help" "Print this message."

__add _sysz_keys "TAB" "Toggle selection."
__add _sysz_keys "ctrl-r" "Run daemon-reload. Selection is reset."
__add _sysz_keys "ctrl-x" "Switch between user and system managers. Selection is reset."
__add _sysz_keys "ctrl-s" "Filter by states. Selection is reset."
__add _sysz_keys "ctrl-t" "Filter by types. Selection is reset."
__add _sysz_keys "ctrl-v" "'cat' the selected units in the preview window."
__add _sysz_keys "ctrl-p" "History previous."
__add _sysz_keys "ctrl-n" "History next."
__add _sysz_keys "left|right" "Toggle word-wrapping in the preview window."
__add _sysz_keys "shift-up" "Scroll up in the preview window."
__add _sysz_keys "shift-down" "Scroll down in the preview window."
__add _sysz_keys "?" "Show keybindings."

__add _sysz_colors active green
__add _sysz_colors failed red
__add _sysz_colors bad red
__add _sysz_colors masked magenta
__add _sysz_colors not-found yellow
__add _sysz_colors template blue
__add _sysz_colors other cyan

__add _sysz_envvars "SYSZ_HISTORY" "Command history file [default: \$XDG_CACHE_HOME/sysz/history]."
__add _sysz_envvars "SYSZ_COLOR" 'Turn colors on or off [default: on].'

function __max_len {
  local max=0
  while read -r -d' ' str; do
    if [[ $max -lt ${#str} ]]; then
      max=${#str}
    fi
  done
  echo "$max"
}

function __print_table {
  # shellcheck disable=SC2178
  local -n map="$1_MAP"
  local -n keys="$1_ORDER"
  local max=0

  for key in "${keys[@]}"; do
    if [[ $max -lt ${#key} ]]; then
      max=${#key}
    fi
  done

  max=$((max + 5))

  for key in "${keys[@]}"; do
    key_len=${#key}
    printf "%s%*s%s\n" "$key" $((max - key_len)) ' ' "${map[$key]}"
    [[ $key = "left|right" ]] && {
      printf "%*s%s\n" "$max" ' ' "Note: fzf does not support horizontal scrolling."
    }
  done
}

function _sysz_help {
  # dynamically generate help message
  cat <<EOF
$_sysz_title

$_sysz_usage

$_sysz_description

OPTS:
$(__print_table _sysz_opts | sed 's/^/  /')

ARGS are passed to the systemctl command for each selected unit.

Keybindings:
$(__print_table _sysz_keys | sed 's/^/  /')

Environment Variables:
$(__print_table _sysz_envvars | sed 's/^/  /' | sed "s|\$XDG_CACHE_HOME|$XDG_CACHE_HOME|")

Units are colored based on their state:
$(__print_table _sysz_colors)

Examples:
  $PROG -u                             User units.
  $PROG --sys -s active                Active system units.
  $PROG --user --state failed          Failed user units.
  $PROG --type socket                  Sockets.
  $PROG --state=inactive -t service    Inactive services.
EOF

}

# dynamically generate sysz help window
! read -r -d '' _fzf_help <<EOM
Keybindings:
$(__print_table _sysz_keys)

$([[ $SYSZ_COLOR = 1 ]] && {
  echo "States:"
  for state in $(__keys _sysz_colors); do
    color=$(__get _sysz_colors "$state")
    echo "  ${!color}$state${reset}"
  done
})

FZF Query Syntax:
  TODO
EOM

function _sysz_quit {
  local code
  code=${1:-$EXITCODE}
  _sysz_debug "quit=$code"
  [[ $DEBUG = true ]] && cat "$DEBUG_FILE" >&2
  exit "$code"
}

function __red {
  echo -e "$red$*$reset"
}

function _sysz_error {
  _sysz_debug "ERROR: $*"
  __red "ERROR: $*" >&2
  _sysz_quit 1
}

function _sysz_debug {
  if [[ $DEBUG = true ]]; then
    echo "$(date -Isec): $*" >>"$DEBUG_FILE"
  fi
}

function _sysz_ctl {
  echo "@@@ $*" >&2
  _sysz_debug "> systemctl $*"
  systemctl "$@"
  return $?
}

function _sysz_verbose {
  [[ $VERBOSE = true ]] && echo '>' "$@" >&2
  _sysz_debug "> $*"
  "$@"
  code=$?
  [[ $VERBOSE = true && $code != 0 ]] && __red "ERROR: Failed: $*" >&2
  return $code
}

function _sysz_systemctl {
  if [[ $EUID -ne 0 && $1 = --system ]]; then
    # only run sudo if we aren't root and it's a system unit
    _sysz_verbose sudo VISUAL="$VISUAL" EDITOR="$EDITOR" SYSTEMD_COLORS="$SYSTEMD_COLORS" systemctl "$@" || EXITCODE=$?
  else
    _sysz_verbose systemctl "$@" || EXITCODE=$?
  fi
  return $?
}

function _sysz_journalctl {
  if [[ $1 = --user ]]; then
    # use --user-unit flag if it's a user unit
    _sysz_verbose journalctl --user-unit="$2" "${@:3}" || EXITCODE=$?
  else
    if [[ $EUID -ne 0 ]]; then
      # only run sudo if we aren't root
      _sysz_verbose sudo SYSTEMD_COLORS="$SYSTEMD_COLORS" journalctl --unit="$2" "${@:3}" || EXITCODE=$?
    else
      _sysz_verbose journalctl --unit="$2" "${@:3}" || EXITCODE=$?
    fi
  fi
  return $?
}

function _sysz_mgr {
  case ${1%% *} in
  '[u'* | user* | --user*)
    echo --user
    ;;
  '[s'* | system* | --system*)
    echo --system
    ;;
  *)
    _sysz_error "Unknown manager: $1"
    ;;
  esac
}

function _fzf_cat {
  _sysz_ctl "$(_sysz_mgr "$1")" cat -- "$2"
}

function _fzf_preview {
  local unit
  local args
  local mgr
  IFS=" " read -r -a args <<<"$1"
  mgr=$(_sysz_mgr "${args[0]}")
  unit=${args[1]}

  if [[ $unit = *@.* ]]; then
    _fzf_cat "${args[@]}"
  else
    _sysz_ctl "$mgr" status --no-pager -- "$unit"
  fi
}

function _sysz_show {
  _sysz_ctl "$(_sysz_mgr "$1")" show "${1##* }" -p "$2" --value
}

function _sysz_colorize_unit {
  local color=$1
  # only add color to the unit name, not the [u]/[s] or description
  # also cut out the extra info in the middle
  sed -Ee 's,^(\[[us]\] )?([^ ]+) [^ ]+ [^ ]+( [^ ]+)?( .*)?$,\1'"$color"'\2'"$reset"'\4,'
}

function _sysz_ls {
  local color=cyan
  local filter=DO_NOT_MATCH
  local state=
  local verb=list-units

  args=()
  for arg in "$@"; do
    case $arg in
    --verb=*)
      verb=${arg#--verb=} # strip --verb=
      continue
      ;;
    --filter=*)
      filter=${arg#--filter=} # strip --filter=
      continue
      ;;
    --state=*)
      state=${arg#--state=} # strip --state=
      color=$(__get _sysz_colors "${arg#--state=}")
      _sysz_debug "color=$color"
      [[ "masked bad" =~ $state ]] && verb=list-unit-files
      ;;
    esac
    args+=("$arg")
  done

  for mgr in "${MANAGERS[@]}"; do
    _sysz_ctl \
      "$verb" \
      "$(_sysz_mgr "$mgr")" \
      --legend=false \
      --full \
      --plain \
      --no-pager \
      --all \
      "${args[@]}" |
      grep -Ev '^\S+\s+(\S+\s+)?('"$filter"')' |
      sed -Ee 's/ +/ /g;' |
      _sysz_colorize_unit "${!color}" |
      sed -e "s/^/[${mgr:0:1}] /" || :
  done
}

function _sysz_units {
  _sysz_debug "_sysz_units"
  _sysz_debug "STATES=${STATES[*]}"
  _sysz_debug "TYPES=${TYPES[*]}"
  if [[ ${#STATES[@]} -gt 0 && ${#TYPES[@]} -gt 0 ]]; then
    for cmd in list-units list-unit-files; do
      for state in "${STATES[@]}"; do
        for unit_type in "${TYPES[@]}"; do
          _sysz_ls "$cmd" "--state=$state" "--type=$unit_type"
        done
      done
    done

  elif [[ ${#STATES[@]} -gt 0 ]]; then
    for cmd in list-units list-unit-files; do
      for state in "${STATES[@]}"; do
        for unit_type in service timer; do
          _sysz_ls "$cmd" "--state=$state" "--type=$unit_type"
        done
        _sysz_ls "$cmd" "--state=$state" |
          grep -Ev '^\[\S+\] \S+(\.service|\.timer)'
      done
    done

  elif [[ ${#TYPES[@]} -gt 0 ]]; then
    for unit_type in "${TYPES[@]}"; do
      if [[ $unit_type = template ]]; then
        _sysz_ls list-unit-files '*@.*'
        continue
      fi
      for state in failed active not-found; do
        _sysz_ls list-units "--state=$state" "--type=$unit_type"
      done
      _sysz_ls "--filter=failed|active|not-found" list-units "--type=$unit_type"
    done

  else
    # failed service
    # failed timer
    # failed units
    # bad service
    # bad timer
    # bad units
    # active service
    # active timer
    # active units
    # masked
    # not-found
    # remaining service
    # remaining timer
    # remaining
    # templates
    _sysz_ls list-units --state=failed --type=service
    _sysz_ls list-units --state=failed --type=timer
    _sysz_ls list-units --state=failed |
      grep -Ev '^\[\S+\] \S+(\.service|\.timer)'
    _sysz_ls list-unit-files --state=bad
    _sysz_ls --state=active --type=service
    _sysz_ls --state=active --type=timer
    _sysz_ls --state=active |
      grep -Ev '^\[\S+\] \S+(\.service|\.timer)'
    # show all not-found units
    _sysz_ls --state=not-found
    # show remaining services
    _sysz_ls '--filter=failed|active|not-found' --type=service
    # show remaining timers
    _sysz_ls '--filter=failed|active|not-found' --type=timer
    # show all remaining units
    _sysz_ls '--filter=failed|active|not-found' |
      grep -Ev '^\[\S+\] \S+(\.service|\.timer)' || :
    # show all templates
    _sysz_ls --verb=list-unit-files | grep -E '@\.'
    _sysz_ls --verb=list-unit-files '*@.*'
  fi
}

# main
_sysz_debug "fzf version=$(fzf --version)"

# check fzf version
if [[ "$(printf '%s\n' "$MIN_FZF_VERSION" "$(fzf --version | cut -d' ' -f1)" | sort -V | head -n1)" != "$MIN_FZF_VERSION" ]]; then
  _sysz_error "fzf >= $MIN_FZF_VERSION required. https://github.com/junegunn/fzf#upgrading-fzf"
fi

# root does not have user units
if [[ $EUID -eq 0 ]]; then
  MANAGERS=(system)
else
  MANAGERS=(user system)
fi

while [[ -n $1 ]]; do
  case $1 in
  -u | --user)
    MANAGERS=(user)
    shift
    ;;
  --sys | --system)
    MANAGERS=(system)
    shift
    ;;
  -s | --state)
    STATES+=("$2")
    shift
    shift
    ;;
  --state=*)
    STATES+=("${1#--state=}")
    shift
    ;;
  -t | --type)
    TYPES+=("$2")
    shift
    shift
    ;;
  --type=*)
    TYPES+=("${1#--type=}")
    shift
    ;;
  --no-color)
    SYSZ_COLOR=0
    shift
    ;;
  -v | --version)
    echo "$PROG" $SYSZ_VERSION
    exit 0
    ;;
  --debug)
    DEBUG=true
    shift
    ;;
  -V | --verbose)
    VERBOSE=true
    shift
    ;;
  -h | --help)
    _sysz_help
    exit 0
    ;;
  *)
    break
    ;;
  esac
done

_sysz_debug "MANAGERS=(${MANAGERS[*]})"
_sysz_debug "STATES=(${STATES[*]})"
_sysz_debug "TYPES=(${TYPES[*]})"
_sysz_debug "VERBOSE=$VERBOSE"
_sysz_debug "SYSZ_COLOR=$SYSZ_COLOR"

function _sysz_check_states {
  for state in "${STATES[@]}"; do
    _sysz_debug "state=$state"
    if [[ -n $state ]] && ! systemctl --state=help | grep -v : | grep -q "^${state}$"; then
      _sysz_error "Invalid state: $state"
    fi
  done
}

function _sysz_check_types {
  for unit_type in "${TYPES[@]}"; do
    _sysz_debug "unit_type=$unit_type"
    if [[ -n $unit_type ]] && ! systemctl --type=help | tail -n +2 | grep -q "^${unit_type}$"; then
      _sysz_error "Invalid type: $unit_type"
    fi
  done
}

function _sysz_fzf {
  local color_arg
  _sysz_debug "_sysz_fzf"
  case "$SYSZ_COLOR" in
  1)
    color_arg=--ansi
    ;;
  0)
    color_arg=--no-color
    ;;
  esac

  fzf \
    --bind "right:toggle-preview-wrap" \
    --bind "left:toggle-preview-wrap" \
    "${color_arg}" \
    "$@"
  return $?
}

_sysz_check_states
_sysz_check_types

while [[ -n $1 ]]; do
  case $1 in
  _fzf_preview)
    shift
    _fzf_preview "$@"
    exit 0
    ;;
  _fzf_cat)
    shift
    _fzf_cat "$@"
    exit 0
    ;;
  _sysz_units)
    _sysz_units
    exit 0
    ;;
  h | help)
    _sysz_help
    exit 0
    ;;
  # Handle short names
  re)
    CMD=restart
    ;;
  s)
    CMD=status
    ;;
  ed)
    CMD=edit
    ;;
  en)
    CMD=enable
    ;;
  d | dis)
    CMD=disable
    ;;
  j)
    CMD=journal
    ;;
  f)
    CMD=follow
    ;;
  c)
    CMD="cat"
    ;;
  --)
    shift
    ARGS=("$@")
    break
    ;;
  -*)
    __red "ERROR: Unknown option: $1" >&2
    cat <<EOF >&2
Usage:
  $_sysz_usage

Options:
$(__print_table _sysz_opts | sed 's/^/  /')
EOF
    exit 1
    ;;
  *)
    # assume the next argument is a command name
    CMD=$1
    ;;
  esac
  shift
done

_sysz_debug "CMD=$CMD"
_sysz_debug "SYSZ_HISTORY=$SYSZ_HISTORY"

mkdir -p "$(dirname "$SYSZ_HISTORY")"
touch "$SYSZ_HISTORY"

function _sysz_mgr_prompt {
  if [[ $EUID -eq 0 ]]; then
    echo system
    return
  fi

  (
    echo user
    echo system
  ) |
    _sysz_fzf \
      --multi \
      --no-info \
      --prompt="Manager: " |
    readarray -t MANAGERS || _sysz_quit $?

  _sysz_debug "MANAGERS=${MANAGERS[*]}"
}

function _sysz_daemon_reload_prompt {
  local managers
  (
    if [[ $EUID -ne 0 ]]; then
      echo 'user'
    fi
    echo 'system'
  ) |
    _sysz_fzf \
      --multi \
      --no-info \
      --prompt="daemon-reload: " |
    readarray -t managers || _sysz_quit $?

  _sysz_debug "daemon-reload=${managers[*]}"

  for mgr in "${managers[@]}"; do
    _sysz_systemctl "$(_sysz_mgr "$mgr")" daemon-reload >&2 || _sysz_error "daemon-reload failed"
  done
}

function _sysz_states_prompt {
  local picked
  # hide 'ing' because they are transient states
  # which people probably aren't looking for
  prefered=(
    failed
    active
    inactive
    masked
    not-found
    enabled
    disabled
    exited
    bad
    error
  )
  (
    echo '(all)'
    printf '%s\n' "${prefered[@]}"
    systemctl --state=help |
      grep -v ':' |
      grep -v 'ing' |
      grep -Ev "^$(
        printf '%s|' "${prefered[@]:0:${#prefered[@]}-1}"
        echo "${prefered[*]: -1}"
      )$" |
      sort -u |
      grep -v '^$'
  ) |
    _sysz_fzf \
      --multi \
      --no-sort \
      --prompt="States: " |
    readarray -t picked || _sysz_quit $?

  _sysz_debug "States=${picked[*]}"

  STATES=()
  for state in "${picked[@]}"; do
    if [[ $state = '(all)' ]]; then
      STATES=()
      return
    fi
    STATES+=("$state")
  done
  _sysz_check_states
}

function _sysz_types_prompt {
  local picked
  (
    echo '(all)'
    echo service
    echo timer
    systemctl --type=help |
      grep -v ':' |
      grep -Ev '(service|timer)' |
      sort -u |
      grep -v '^$'
    echo template
  ) |
    _sysz_fzf \
      --multi \
      --no-sort \
      --prompt="Types: " |
    readarray -t picked || _sysz_quit $?

  _sysz_debug "Types=${picked[*]}"

  TYPES=()
  for type in "${picked[@]}"; do
    if [[ $type = '(all)' ]]; then
      TYPES=()
      return
    fi
    TYPES+=("$type")
  done
  _sysz_check_types
}

function _sysz_tmpl_prompt {
  local unit
  unit=$1
  # Handle template units
  if [[ $unit = *@.* ]]; then
    read -r -p "$unit requires a parameter: " tmpl_param
    _sysz_debug "tmpl_param=$tmpl_param"
    if [[ -z $tmpl_param ]]; then
      _sysz_error "$unit requires a parameter"
    fi

    unit=${unit/\@/\@${tmpl_param}}
    _sysz_debug "template unit=$unit"
  fi
  echo "$unit"
}

function _sysz_cmd {
  local color=$1
  shift
  local cmd=$1
  shift

  if [[ ${#ARGS[@]} -gt 0 ]]; then
    echo "$color$cmd$reset ${ARGS[*]}"
  else
    echo "$color$cmd$reset"
  fi
}

declare key
declare multi
declare -a picks
declare -a cmds

function _sysz_prompt_units {
  _sysz_units |
    _sysz_fzf \
      --multi \
      --tiebreak=begin,end,index \
      --nth=2.. \
      --expect=ctrl-r,ctrl-s,ctrl-x,ctrl-t \
      --history="$SYSZ_HISTORY" \
      --prompt="Units: " \
      --header '? for keybindings' \
      --bind "?:preview(echo '$_fzf_help')" \
      --bind "ctrl-v:preview('${BASH_SOURCE[0]}' _fzf_cat {})" \
      --preview="'${BASH_SOURCE[0]}' _fzf_preview {}" \
      --preview-window=down
}

function _sysz_prompt_commands {
  declare -a picks
  picks=("$@")

  if [[ ${#picks[@]} -gt 1 ]]; then
    printf -v preview '%s\n' "${picks[*]}"
    _sysz_debug "preview=$preview"
    preview_cmd="echo -n '$preview'"
    _sysz_debug "preview_cmd=$preview_cmd"
    multi=true
  else
    pick=${picks[0]}
    _sysz_debug "pick=$pick"

    #pick=$(_sysz_tmpl_prompt "$pick")

    # Get states to filter the command options
    active_state=$(_sysz_show "$pick" ActiveState)
    _sysz_debug "active_state=$active_state"
    load_state=$(_sysz_show "$pick" LoadState)
    _sysz_debug "load_state=$load_state"
    [[ $load_state = not-found ]] && _sysz_error "$pick not found"
    unit_file_state=$(_sysz_show "$pick" UnitFileState)
    _sysz_debug "unit_file_state=$unit_file_state"
    can_reload=$(_sysz_show "$pick" CanReload)
    _sysz_debug "can_reload=$can_reload"
    preview_cmd="'${BASH_SOURCE[0]}' _fzf_preview '$pick'"
    _sysz_debug "preview_cmd=$preview_cmd"
  fi

  _sysz_debug "multi=$multi"

  _sysz_fzf \
    --multi \
    --ansi \
    --no-info \
    --no-sort \
    --prompt="Commands: " \
    --preview="$preview_cmd" \
    --preview-window=80% < <(
      # restart
      [[ $multi = true || $active_state = active ]] &&
        _sysz_cmd "$red" restart
      # start
      [[ $multi = true || $active_state != active ]] &&
        _sysz_cmd "$green" start
      # stop
      [[ $multi = true || $active_state = active ]] &&
        _sysz_cmd "$red" stop
      # enable
      [[ $multi = true || $unit_file_state != enabled ]] &&
        _sysz_cmd "$green" enable
      # disable
      [[ $multi = true || $unit_file_state = enabled ]] &&
        _sysz_cmd "$red" disable

      _sysz_cmd "$reset" status
      _sysz_cmd "$reset" journal
      _sysz_cmd "$reset" follow

      # reload
      [[ $multi = true || $can_reload = yes ]] &&
        _sysz_cmd "$gray" reload

      # mask
      [[ $multi = true || ($unit_file_state != masked && $load_state != masked) ]] &&
        _sysz_cmd "$red" mask
      [[ $multi = true || $unit_file_state = masked || $load_state = masked ]] &&
        _sysz_cmd "$green" unmask

      _sysz_cmd "$reset" cat
      _sysz_cmd "$reset" edit
      _sysz_cmd "$reset" show
    ) || _sysz_quit $?
}

function _sysz_handle_key {
  local key=$1
  _sysz_debug "key=$key"
  case $key in
  ctrl-r)
    _sysz_daemon_reload_prompt
    return
    ;;
  ctrl-t)
    _sysz_types_prompt
    return
    ;;
  ctrl-s)
    _sysz_states_prompt
    return
    ;;
  ctrl-x)
    _sysz_mgr_prompt
    return
    ;;
  esac
  return 1
}

declare -a results
while :; do
  _sysz_prompt_units | readarray -t picks
  _sysz_debug "picks=${picks[*]:1}"

  # The first result from fzf is always the key
  _sysz_handle_key "${picks[0]}" || break
done

declare -p picks
# results look like '[s] foo.service With a description'
for result in "${results[@]:1}"; do                      
  _sysz_debug "result=$result"                           
  # read the first 2 words and throw away the rest       
  IFS=" " read -r -a words <<<"$result"                  
  _sysz_debug "words=${words[*]}"                       
  # picks are of the form: [s] foo.service              
  picks+=("${words[0]} ${words[1]}")                    
done                                                    
          
if [[ ${#picks[@]} -eq 0 ]]; then
  _sysz_quit 1
fi

function _sysz_handle_command {
  local pick=$1
  local cmd=$2
  local mgr
  local unit

  _sysz_debug "pick=$pick"
  mgr=$(_sysz_mgr "$pick")
  _sysz_debug "mgr=$mgr"
  unit=${pick##* }
  _sysz_debug "unit=$unit"

  _sysz_debug "unit=$unit"
  _sysz_debug "cmd=$cmd"
  # remove surrounding whitespace
  cmd=${cmd%% *}
  cmd=${cmd##* }
  _sysz_debug "cmd=$cmd"
  case $cmd in
  edit)
    _sysz_systemctl "$mgr" cat -- "$unit" | cksum | read -r pre_sum
    _sysz_systemctl "$mgr" edit -- "$unit" 
    _sysz_systemctl "$mgr" cat -- "$unit" | cksum | read -r post_sum
    if [[ $pre_sum != "$post_sum" ]]; then
      _sysz_systemctl "$mgr" daemon-reload
      _sysz_do_commands "$pick"
    fi
    ;;
  journal)
    _sysz_journalctl "$mgr" "$unit" -xe "${ARGS[@]}"
    ;;
  follow)
    set -x
    _sysz_journalctl "$mgr" "$unit" -xef "${ARGS[@]}"
    ;;
  status)
    _sysz_systemctl "$mgr" "$cmd" --pager "${ARGS[@]}" -- "$unit"
    ;;
  cat | show)
    _sysz_systemctl "$mgr" "$cmd" --no-pager "${ARGS[@]}" -- "$unit"
    ;;
  *)
    _sysz_systemctl "$mgr" "$cmd" --no-block "${ARGS[@]}" -- "$unit"
    _sysz_systemctl "$mgr" status --no-pager -- "$unit"
    ;;
  esac
}

function _sysz_do_commands {
  declare -a picks
  picks=("$@")
  declare -a cmds
  if [[ $CMD ]]; then
    cmds=("$CMD")
  else
    _sysz_prompt_commands "${picks[@]}" | readarray -t cmds
  fi
  _sysz_debug "cmds=${cmds[*]}"

  for pick in "${picks[@]}"; do
    for cmd in "${cmds[@]}"; do
      _sysz_handle_command "$pick" "$cmd"
    done
  done
}

_sysz_quit
