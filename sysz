#!/bin/bash
# shellcheck disable=SC2086

shopt -s lastpipe

_sysz_help() {
  PROG=$(basename "$0")
  cat >&2 <<EOF
A utility for using systemctl interactively via fzf.

Usage: $PROG [OPT] [CMD] [ARGS...]

Select multiple units using TAB

Extra ARGS are passed to the systemctl command.

OPT:
  -u, --user             Only show --user services
  -s, --sys, --system    Only show --user services
  -a, --active           Only show active services
  -h, --help             Print this message

If no option is given, both system and user units are shown.

CMD:
  start                  systemctl start <unit>
  stop                   systemctl stop <unit>
  re, restart            systemctl restart <unit>
  s, stat, status        systemctl status <unit>
  ed, edit               systemctl edit --full <unit>
  reload                 systemctl reload <unit>
  en, enable             systemctl enable --now <unit>
  d, dis, disable        systemctl disable --now <unit>

If no command is given, one can be chosen interactively based on state.

Examples:
  $PROG --system stat      Get the status of a system unit
  $PROG --user --edit      Edit a user unit
  $PROG start              Start a unit
  $PROG -u s -n100         Show status of a user unit with 100 log lines.
EOF

  exit 1
}

_sysz_manager() {
  if [[ $1 = '[system]' ]]; then
    echo --system
  elif [[ $1 = '[user]' ]]; then
    echo --user
  fi
}

_sysz_systemctl() {
  manager=$(_sysz_manager "$1")
  shift
  local unit=$1
  shift
  local cmd=$1
  shift
  if [[ $EUID -ne 0 && $manager = --system ]]; then
    # only run sudo if we aren't root and it's a system unit
    sudo systemctl "$manager" "$cmd" "$unit" "$@"
  else
    systemctl "$manager" "$cmd" "$unit" "$@"
  fi
}

_sysz_preview() {
  export SYSTEMD_COLORS=1
  _sysz_systemctl "$1" status "$2" --no-pager
}

_sysz_show() {
  _sysz_systemctl "$1" "$2" show -p "$3" --value
}

_sysz_list_cmd() {
  systemctl \
    "$1" \
    list-units \
    --all \
    --no-legend \
    --full \
    --no-pager \
    $ACTIVE |
    awk '{print $1}'

}

_sysz_sort() {
  while IFS= read -r string; do
    if [[ $string =~ \[user\].*\.service$ ]]; then
      # user services
      echo "0 $string"
    elif [[ $string =~ \.service$ ]]; then
      # system services
      echo "1 $string"
    elif [[ $string =~ \[user\].*\.timers$ ]]; then
      # user timers
      echo "2 $string"
    elif [[ $string =~ \.timer$ ]]; then
      # system timers
      echo "3 $string"
    elif [[ $string =~ \[user\].*\.socket$ ]]; then
      # user sockets
      echo "4 $string"
    elif [[ $string =~ \.socket$ ]]; then
      # system sockets
      echo "5 $string"
    elif [[ $string =~ \[user\] ]]; then
      # then user units based on file extenions
      echo "7${string##*.} $string"
    else
      # then the rest based on file extension
      echo "8${string##*.} $string"
    fi
  done | sort | cut -d' ' -f2-
}

_sysz_list() {
  if [[ $UNITS = user || $UNITS = all ]]; then
    _sysz_list_cmd --user | sed -e 's/^/[user] /'
  fi

  if [[ $UNITS = system || $UNITS = all ]]; then
    _sysz_list_cmd --system | sed -e 's/^/[system] /'
  fi
}

_sysz_journal() {
  manager=$(_sysz_manager "$1")
  shift
  unit=$1
  shift
  if [[ $EUID -ne 0 && $manager = --system ]]; then
    # only run sudo if we aren't root and it's a system unit
    sudo journalctl "$manager" "--unit=$unit" -xe "$@"
  else
    journalctl "$manager" "--unit=$unit" -xe "$@"
  fi
}

UNITS=all
while [[ -n $1 ]]; do
  case $1 in
  -u | --user)
    UNITS=user
    shift
    ;;
  -s | --sys | --system)
    UNITS=system
    shift
    ;;
  -a | --active)
    ACTIVE="--state=active"
    shift
    ;;
  -h | --help)
    _sysz_help
    ;;
  *)
    break
    ;;
  esac
done

CMD=
while :; do
  case $1 in
  h | help)
    _sysz_help
    ;;
  # Handle short names
  re)
    CMD=restart
    ;;
  s)
    CMD=status
    ;;
  ed)
    CMD=edit
    ;;
  en)
    CMD=enable
    ;;
  d | dis)
    CMD=disable
    ;;
  preview)
    shift
    _sysz_preview "$@"
    exit 0
    ;;
  j)
    CMD=journal
    ;;
  f)
    CMD=follow
    ;;
  c)
    CMD="cat"
    ;;
  *)
    # assume the next argument is a command name
    CMD=$1
    break
    ;;
  esac
  shift
  break
done

ARGS=$*

_sysz_list | _sysz_sort |
  fzf --multi --ansi --preview="'${BASH_SOURCE[0]}' preview {}" |
  while read -r UNIT && [[ -n $UNIT ]]; do

    ACTIVE_STATE=$(_sysz_show $UNIT ActiveState)
    UNIT_FILE_STATE=$(_sysz_show $UNIT UnitFileState)
    CAN_RELOAD=$(_sysz_show $UNIT CanReload)

    if [[ -z $CMD ]]; then
      fzf \
        --reverse \
        --ansi \
        --bind=enter:replace-query+print-query \
        --prompt="Select systemctl command: " < <(
          echo status
          [[ $ACTIVE_STATE = active ]] && echo restart
          [[ $ACTIVE_STATE != active ]] && printf '\033[0;32m%s\033[0m\n' start
          [[ $ACTIVE_STATE = active ]] && printf '\033[0;31m%s\033[0m\n' stop
          [[ $UNIT_FILE_STATE != enabled ]] && printf '\033[0;32m%s\033[0m\n' enable
          [[ $UNIT_FILE_STATE = enabled ]] && printf '\033[0;31m%s\033[0m\n' disable
          [[ $CAN_RELOAD = yes ]] && printf '\033[0;37m%s\033[0m\n' reload
          echo edit
          echo journal
          echo follow
        ) |
        read -r CMD
    fi

    if [[ -z $CMD ]]; then
      exit 1
    fi

    case $CMD in
    enable | disable)
      ARGS="$ARGS --now"
      ;;
    esac

    case $CMD in
    follow)
      _sysz_journal $UNIT -f
      ;;
    journal)
      _sysz_journal $UNIT
      ;;
    status)
      _sysz_systemctl $UNIT "$CMD" --no-pager
      ;;
    cat)
      _sysz_systemctl $UNIT "$CMD"
      ;;
    *)
      _sysz_systemctl $UNIT "$CMD"
      _sysz_systemctl $UNIT status
      ;;
    esac

  done
