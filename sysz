#!/usr/bin/env bash

# shell options
#set -o xtrace
set -o pipefail
shopt -s lastpipe
shopt -s extglob

#set -o errexit
#set -o errtrace
shopt -s extdebug

#trap 'echo ERROR:$0:${LINENO} $BASH_COMMAND >&2' ERR

# constants
declare -rx SHELL=bash
declare -r MIN_FZF_VERSION=0.27.1
sysz_prog=$(basename "$0")
declare -r sysz_prog
declare -r sysz_version=2.0.0-beta
sysz_debug_file=debug.$(date -Iminutes).log
declare -r sysz_debug_file

# variables

# environment variables
export XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
export SYSZ_HISTORY=${SYSZ_HISTORY:-$XDG_CACHE_HOME/sysz/history}
case "$SYSZ_COLORS" in
[nN][oO] | [oO][fF][fF] | [fF][aA][lL][sS][eE] | 0)
  export SYSZ_COLORS=0
  ;;
*)
  ncolors=$(tput colors)

  if [[ -n $ncolors && $ncolors -ge 8 ]]; then
    export SYSZ_COLORS=1
  else
    export SYSZ_COLORS=0
  fi
  ;;
esac
export SYSTEMD_COLORS=${SYSTEMD_COLORS:-$SYSZ_COLORS}
if [[ $SYSZ_COLORS -eq 1 ]]; then
  declare -rA colors=(
    [none]=''
    [reset]=$'\e[0m'
    [red]=$'\e[31m'
    [green]=$'\e[32m'
    [yellow]=$'\e[33m'
    [blue]=$'\e[34m'
    [magenta]=$'\e[35m'
    [cyan]=$'\e[36m'
    [gray]=$'\e[37m'
  )
else
  declare -rA colors=(
    [none]=''
    [reset]=''
    [red]=''
    [green]=''
    [yellow]=''
    [blue]=''
    [magenta]=''
    [cyan]=''
    [gray]=''
  )
fi
export SYSZ_VERBOSE=${SYSZ_VERBOSE:-false}
export SYSZ_DEBUG=${SYSZ_DEBUG:-false}

# global variables
declare -a sysz_cmds
declare -a sysz_args
declare exitcode=0
declare -a sysz_managers
declare -a sysz_states
declare -a sysz_types

# Data Structures
#   Unit
#     Type
#     Name
#     Description
#     LoadState
#     ActiveState
#     UnitFileState
#     CanReload
#     Manager

function __max_len() {
  local max=0
  while read -r -d' ' str; do
    if [[ $max -lt ${#str} ]]; then
      max=${#str}
    fi
  done
  echo "$max"
}

# ordered assocative array helpers
# https://stackoverflow.com/a/72263994/334632
function __add() {
  local var=$1
  local key=$2
  local val=$3
  declare -ga "${var}_ORDER"
  declare -gA "${var}_MAP"
  local -n map=${var}_MAP
  local -n order=${var}_ORDER
  order+=("$key")
  map["$key"]=$val
}

function __get() {
  local var=$1
  local key=$2
  local -n tmp=${var}_MAP
  echo "${tmp[$key]}"
}

function __keys() {
  local var=$1
  local -n tmp=${var}_ORDER
  for x in "${tmp[@]}"; do
    echo "$x"
  done
}

function __values() {
  local var=$1
  # shellcheck disable=SC2178
  local -n map=${var}_MAP
  # shellcheck disable=SC2178
  local -n order=${var}_ORDER
  for k in "${order[@]}"; do
    echo -n "${map[$k]} "
  done
  echo
}

function _sysz_short_help() {
  cat <<EOF
$sysz_prog [OPTS...] [CMD...] [-- ARGS...]

OPTS:
  -u, --user                  Only show --user units [default].
  --sys, --system             Only show --system units [default].
  -s STATE, --state STATE     Only show units in STATE (repeatable).
  -t TYPE, --type TYPE        Only show units of TYPE (repeatable).
  --no-color                  Disable colors.
  -V, --verbose               Print the systemctl command.
  -v, --version               Print the version.
  -h                          Print this message.
  --help                      Print full help message.
EOF
}

_sysz_print_keybindings() {
  cat <<EOF
Keybindings:
  TAB            Toggle selection.
  ctrl-r         Run daemon-reload. Selection is reset.
  ctrl-x         Switch between user and system managers. Selection is reset.
  ctrl-s         Filter by states. Selection is reset.
  ctrl-t         Filter by types. Selection is reset.
  ctrl-v         'cat' the selected units in the preview window.
  ctrl-p         History previous.
  ctrl-n         History next.
  left|right     Toggle word-wrapping in the preview window.
                 Note: fzf does not support horizontal scrolling.
  shift-up       Scroll up in the preview window.
  shift-down     Scroll down in the preview window.
  ?              Show keybindings.
EOF
}

function _sysz_help() {
  cat <<EOF
$sysz_prog - interactive terminal UI for systemctl

$sysz_prog [OPTS...] [CMD...] [-- ARGS...]

sudo is invoked automatically, if necessary.

If only one unit is chosen, available commands will be presented
based on the state of the unit (e.g. "start" only shows if unit is "active").

OPTS:
  -u, --user                  Only show --user units [default].
  --sys, --system             Only show --system units [default].
  -s STATE, --state STATE     Only show units in STATE (repeatable).
  -t TYPE, --type TYPE        Only show units of TYPE (repeatable).
  --no-color                  Disable colors.
  -V, --verbose               Print the systemctl command.
  -v, --version               Print the version.
  -h, --help                  Print this message.

ARGS are passed to the systemctl command for each selected unit.

EOF

  _sysz_print_keybindings

  cat <<EOF

Environment Variables:
  SYSZ_HISTORY     Command history file [default: $XDG_CACHE_HOME/sysz/history].
  SYSZ_COLORS      Turn colors on or off [default: on].

EOF
  [[ $SYSZ_COLORS -eq 1 ]] && cat <<EOF
Units are colored based on their state:
  $(_sysz_color red "failed        red")
  $(_sysz_color green "active        green")
  $(_sysz_color yellow "not-found     yellow")
  $(_sysz_color magenta "masked        magenta")
  $(_sysz_color cyan "template      blue")

EOF

  cat <<EOF
Examples:
  $sysz_prog -u                             User units.
  $sysz_prog --sys -s active                Active system units.
  $sysz_prog --user --state failed          Failed user units.
  $sysz_prog --type socket                  Sockets.
  $sysz_prog --state=inactive -t service    Inactive services.
EOF

}

function _sysz_quit() {
  local code=${1:-$exitcode}
  _sysz_debug "quit=$code"
  [[ $SYSZ_DEBUG = true ]] && cat "$sysz_debug_file" >&2
  exit "$code"
}

function _sysz_color() {
  local color=$1
  shift
  echo -en "${colors[$color]}"
  echo -n "$*"
  echo -e "${colors[reset]}"
}

function _sysz_error() {
  _sysz_debug "ERROR: $*"
  _sysz_color red "ERROR: $*" >&2
}

function _sysz_debug() {
  [[ $SYSZ_DEBUG = true ]] && echo "$(date -Isec): $*" >>"$sysz_debug_file"
}

function _sysz_verbose() {
  [[ $SYSZ_VERBOSE = true ]] && echo "> $*" >&2
  _sysz_debug "> $*"
  "$@"
  code=$?
  [[ $code != 0 ]] && _sysz_error "Failed: $*"
  return "$code"
}

function _sysz_ctl() {
  _sysz_verbose systemctl "$@"
}

function _sysz_sudo_ctl() {
  if [[ $EUID -ne 0 && $1 = --system ]]; then
    # only run sudo if we aren't root and it's a system unit
    _sysz_verbose sudo -E systemctl "$@" || exitcode=$?
  else
    _sysz_verbose systemctl "$@" || exitcode=$?
  fi
}

function _sysz_journalctl() {
  if [[ $1 = --user ]]; then
    # use --user-unit flag if it's a user unit
    _sysz_verbose journalctl --user-unit="$2" "${@:3}" || exitcode=$?
  else
    if [[ $EUID -ne 0 ]]; then
      # only run sudo if we aren't root
      _sysz_verbose sudo SYSTEMD_COLORS="$SYSTEMD_COLORS" journalctl --unit="$2" "${@:3}" || exitcode=$?
    else
      _sysz_verbose journalctl --unit="$2" "${@:3}" || exitcode=$?
    fi
  fi
}

function _sysz_mgr() {
  case ${1%% *} in
  '[u'* | user* | --user*)
    echo --user
    ;;
  '[s'* | system* | --system*)
    echo --system
    ;;
  *)
    _sysz_error "Unknown manager: $1"
    _sysz_quit 1
    ;;
  esac
}

function _sysz_fzf_cat() {
  _sysz_ctl "$(_sysz_mgr "$1")" cat -- "$2"
}

function _sysz_fzf_unit_preview() {
  local unit
  local args
  local mgr
  IFS=" " read -r -a args <<<"$1"
  mgr=$(_sysz_mgr "${args[0]}")
  unit=${args[1]}

  if [[ $unit = *@.* ]]; then
    _sysz_fzf_cat "${args[@]}"
  else
    systemctl "$mgr" status --no-pager -- "$unit"
  fi
}

function _sysz_show() {
  _sysz_ctl "$(_sysz_mgr "$1")" show "${1##* }" -p "$2" --value
}

function _sysz_clean() {
  # remove all colors and control characters from stdin
  sed -e 's/\x1b\[[0-9;]*m//g'
}

function _sysz_print_unit() {
  local color=$1
  local mgr=$2
  local unit=$3
  local desc=$4

  echo -n "[${mgr:0:1}] "
  echo -en "${colors[$color]}"
  echo -n "$unit"
  echo -en "${colors[reset]}"
  [[ $desc ]] && echo -n " - $desc"
  echo
}

declare -r sysz_ls_units_cmd="_sysz_ctl --plain --no-pager --no-legend --full --all"

function _sysz_ls() {
  local color=$1
  shift
  local inactive
  [[ $* = *"--state=inactive"* ]] && inactive=true

  for mgr in "${sysz_managers[@]}"; do
    $sysz_ls_units_cmd --"$mgr" "$@" | _sysz_clean |
      while read -r unit load active sub desc; do
        if [[ $inactive && $load = not-found ]]; then
          # don't include "not-found" when showing inactive units
          continue
        fi
        _sysz_print_unit "$color" "$mgr" "$unit" "$desc"
      done
  done
}

function _sysz_all_units() {
  active_states=(
    --state=active
    --state=reloading
    --state=activating
    --state=deactivating
  )
  systemctl --type=help | grep -Ev ':|service|timer' | sed 's/^/--type=/' | readarray -t other_types

  # failed
  _sysz_ls red list-units --failed

  # active services and timers
  _sysz_ls green list-units --type=service --type=timer "${active_states[@]}"

  # other active units
  _sysz_ls green list-units "${other_types[@]}" "${active_states[@]}"

  # inactive services and timers
  _sysz_ls none list-units --type=service --type=timer --state=inactive

  # other inactive units
  _sysz_ls none list-units "${other_types[@]}" --state=inactive

  # not found
  _sysz_ls yellow list-units --state=not-found

  # masked
  _sysz_ls magenta list-units --state=masked

  # templates
  _sysz_ls cyan list-unit-files '*@.*'

  # everything from list-unit-files that isn't in list-units or a template
  for mgr in "${sysz_managers[@]}"; do
    while comm -13 \
      <($sysz_ls_units_cmd list-units | cut -f1 -d' ' | _sysz_clean | sort -u) \
      <($sysz_ls_units_cmd list-unit-files '*[!@].*' | _sysz_clean | cut -f1 -d' ' | sort -u) |
      read -r unit; do
      _sysz_print_unit none "$mgr" "$unit"
    done
  done
}

function _sysz_fzf() {
  local color_arg
  _sysz_debug "_sysz_fzf"
  case "$SYSZ_COLORS" in
  1)
    color_arg=--ansi
    ;;
  0)
    color_arg=--no-color
    ;;
  esac

  fzf \
    --bind "right:toggle-preview-wrap" \
    --bind "left:toggle-preview-wrap" \
    "${color_arg}" \
    "$@"
}

function _sysz_mgr_prompt() {
  if [[ $EUID -eq 0 ]]; then
    echo system
    return
  fi

  (
    echo user
    echo system
  ) |
    _sysz_fzf \
      --multi \
      --no-info \
      --prompt="Manager: " |
    readarray -t sysz_managers || _sysz_quit $?

  _sysz_debug "sysz_managers=${sysz_managers[*]}"
}

function _sysz_daemon_reload_prompt() {
  local managers
  (
    if [[ $EUID -ne 0 ]]; then
      echo 'user'
    fi
    echo 'system'
  ) |
    _sysz_fzf \
      --multi \
      --no-info \
      --prompt="daemon-reload: " |
    readarray -t managers || _sysz_quit $?

  _sysz_debug "daemon-reload=${managers[*]}"

  for mgr in "${managers[@]}"; do
    _sysz_sudo_ctl "$(_sysz_mgr "$mgr")" daemon-reload >&2 || {
      _sysz_error "daemon-reload failed"
      _sysz_quit 1
    }
  done
}

function _sysz_ls_states() {
  local prefered=(
    failed
    active
    inactive
    masked
    not-found
    enabled
    disabled
    exited
    bad
    error
  )
  echo '(all)'
  printf '%s\n' "${prefered[@]}"

  # hide 'ing' because they are transient states
  # which you probably aren't looking for
  systemctl --state=help |
    grep -v ':' |
    grep -v 'ing' |
    grep -Ev "^$(
      printf '%s|' "${prefered[@]:0:${#prefered[@]}-1}"
      echo "${prefered[*]: -1}"
    )$" |
    sort -u |
    grep -v '^$'
}

function _sysz_states_prompt() {
  _sysz_ls_states |
    _sysz_fzf \
      --multi \
      --no-sort \
      --prompt="States: " |
    readarray -t sysz_states || _sysz_quit $?

  _sysz_debug "Picked states: ${sysz_states[*]}"

  for state in "${sysz_states[@]}"; do
    if [[ $state = '(all)' ]]; then
      sysz_states=()
      return
    fi
  done
  _sysz_check_states
}

function _sysz_ls_types() {
  echo '(all)'
  echo service
  echo timer
  systemctl --type=help |
    grep -Ev ':|service|timer' |
    sort -u |
    grep -v '^$'
  echo template
}

function _sysz_types_prompt() {
  _sysz_ls_types |
    _sysz_fzf \
      --multi \
      --no-sort \
      --prompt="Types: " |
    readarray -t sysz_types || _sysz_quit $?

  _sysz_debug "Picked types: ${sysz_types[*]}"

  for type in "${sysz_types[@]}"; do
    if [[ $type = '(all)' ]]; then
      sysz_types=()
      return
    fi
  done
  _sysz_check_types
}

function _sysz_tmpl_prompt() {
  local unit
  unit=$1
  # Handle template units
  if [[ $unit = *@.* ]]; then
    read -r -p "$unit requires a parameter: " tmpl_param
    _sysz_debug "tmpl_param=$tmpl_param"
    if [[ -z $tmpl_param ]]; then
      _sysz_error "$unit requires a parameter"
      _sysz_quit 1
    fi

    unit=${unit/\@/\@${tmpl_param}}
    _sysz_debug "template unit=$unit"
  fi
  echo "$unit"
}

function _sysz_cmd() {
  local color=$1
  shift
  local cmd=$1
  shift

  if [[ ${#sysz_args[@]} -gt 0 ]]; then
    echo -e "$color$cmd$reset ${sysz_args[*]}"
  else
    echo -e "$color$cmd$reset"
  fi
}

function _sysz_prompt_units() {
  _sysz_all_units |
    _sysz_fzf \
      --multi \
      --tiebreak=begin,end,index \
      --nth=2.. \
      --expect=ctrl-r,ctrl-s,ctrl-x,ctrl-t \
      --history="$SYSZ_HISTORY" \
      --prompt="Units: " \
      --header '? for keybindings' \
      --bind "?:preview(echo '$_sysz_fzf_help')" \
      --bind "ctrl-v:preview('${BASH_SOURCE[0]}' _sysz_fzf_cat {})" \
      --preview="'${BASH_SOURCE[0]}' _sysz_fzf_unit_preview {}" \
      --preview-window=down
}

function _sysz_prompt_cmds() {
  if [[ ${#sysz_units[@]} -gt 1 ]]; then
    printf -v preview '%s\n' "${picks[*]}"
    _sysz_debug "preview=$preview"
    preview_cmd="echo -n '$preview'"
    _sysz_debug "preview_cmd=$preview_cmd"
    multi=true
  else
    pick=${picks[0]}
    _sysz_debug "pick=$pick"

    # TODO: Move this to after the command is selected
    #pick=$(_sysz_tmpl_prompt "$pick")

    # Get states to filter the command options
    active_state=$(_sysz_show "$pick" ActiveState)
    _sysz_debug "active_state=$active_state"
    load_state=$(_sysz_show "$pick" LoadState)
    _sysz_debug "load_state=$load_state"
    [[ $load_state = not-found ]] && {
      _sysz_error "$pick not found"
      _sysz_quit 1
    }
    unit_file_state=$(_sysz_show "$pick" UnitFileState)
    _sysz_debug "unit_file_state=$unit_file_state"
    can_reload=$(_sysz_show "$pick" CanReload)
    _sysz_debug "can_reload=$can_reload"
    preview_cmd="'${BASH_SOURCE[0]}' _sysz_fzf_unit_preview '$pick'"
    _sysz_debug "preview_cmd=$preview_cmd"
  fi

  _sysz_debug "multi=$multi"

  _sysz_fzf \
    --multi \
    --ansi \
    --no-info \
    --no-sort \
    --prompt="Commands: " \
    --preview="$preview_cmd" \
    --preview-window=80% < <(
      # restart
      [[ $multi = true || $active_state = active ]] &&
        _sysz_cmd "$red" restart
      # start
      [[ $multi = true || $active_state != active ]] &&
        _sysz_cmd "$green" start
      # stop
      [[ $multi = true || $active_state = active ]] &&
        _sysz_cmd "$red" stop
      # enable
      [[ $multi = true || $unit_file_state != enabled ]] &&
        _sysz_cmd "$green" enable
      # disable
      [[ $multi = true || $unit_file_state = enabled ]] &&
        _sysz_cmd "$red" disable

      _sysz_cmd "$reset" status
      _sysz_cmd "$reset" journal
      _sysz_cmd "$reset" follow

      # reload
      [[ $multi = true || $can_reload = yes ]] &&
        _sysz_cmd "$gray" reload

      # mask
      [[ $multi = true || ($unit_file_state != masked && $load_state != masked) ]] &&
        _sysz_cmd "$red" mask
      [[ $multi = true || $unit_file_state = masked || $load_state = masked ]] &&
        _sysz_cmd "$green" unmask

      _sysz_cmd "$reset" cat
      _sysz_cmd "$reset" edit
      _sysz_cmd "$reset" show
    ) || _sysz_quit $?
}

function _sysz_handle_key() {
  local key=$1
  _sysz_debug "_sysz_handle_key"
  _sysz_debug "key=$key"
  case $key in
  ctrl-r)
    _sysz_daemon_reload_prompt
    return
    ;;
  ctrl-t)
    _sysz_types_prompt
    return
    ;;
  ctrl-s)
    _sysz_states_prompt
    return
    ;;
  ctrl-x)
    _sysz_mgr_prompt
    return
    ;;
  esac
  return 1
}

function _sysz_handle_command() {
  local pick=$1
  local cmd=$2
  local mgr
  local unit

  _sysz_debug "pick=$pick"
  mgr=$(_sysz_mgr "$pick")
  _sysz_debug "mgr=$mgr"
  unit=${pick##* }
  _sysz_debug "unit=$unit"

  _sysz_debug "unit=$unit"
  _sysz_debug "cmd=$cmd"
  # remove surrounding whitespace
  cmd=${cmd%% *}
  cmd=${cmd##* }
  _sysz_debug "cmd=$cmd"
  case $cmd in
  edit)
    _sysz_sudo_ctl "$mgr" cat -- "$unit" | cksum | read -r pre_sum
    _sysz_sudo_ctl "$mgr" edit -- "$unit"
    _sysz_sudo_ctl "$mgr" cat -- "$unit" | cksum | read -r post_sum
    if [[ $pre_sum != "$post_sum" ]]; then
      _sysz_sudo_ctl "$mgr" daemon-reload
      _sysz_do_commands "$pick"
    fi
    ;;
  journal)
    _sysz_journalctl "$mgr" "$unit" -xe "${sysz_args[@]}"
    ;;
  follow)
    set -x
    _sysz_journalctl "$mgr" "$unit" -xef "${sysz_args[@]}"
    ;;
  status)
    _sysz_sudo_ctl "$mgr" "$cmd" --pager "${sysz_args[@]}" -- "$unit"
    ;;
  cat | show)
    _sysz_sudo_ctl "$mgr" "$cmd" --no-pager "${sysz_args[@]}" -- "$unit"
    ;;
  *)
    _sysz_sudo_ctl "$mgr" "$cmd" --no-block "${sysz_args[@]}" -- "$unit"
    _sysz_sudo_ctl "$mgr" status --no-pager -- "$unit"
    ;;
  esac
}

function _sysz_do_commands() {
  declare -a picks
  picks=("$@")
  declare -a cmds
  if [[ $CMD ]]; then
    cmds=("$CMD")
  else
    _sysz_prompt_commands "${picks[@]}" | readarray -t cmds
  fi
  _sysz_debug "cmds=${cmds[*]}"

  for pick in "${picks[@]}"; do
    for cmd in "${cmds[@]}"; do
      _sysz_handle_command "$pick" "$cmd"
    done
  done
}

function _sysz_check_states() {
  for state in "${sysz_states[@]}"; do
    _sysz_debug "state=$state"
    if [[ -n $state ]] && ! systemctl --state=help | grep -v : | grep -q "^${state}$"; then
      _sysz_error "Invalid state: $state"
      _sysz_quit 1
    fi
  done
}

function _sysz_check_types() {
  for unit_type in "${sysz_types[@]}"; do
    _sysz_debug "unit_type=$unit_type"
    if [[ -n $unit_type && $unit_type != template ]] && ! systemctl --type=help | tail -n +2 | grep -q "^${unit_type}$"; then
      _sysz_error "Invalid type: $unit_type"
      _sysz_quit 1
    fi
  done
}

function _sysz_check_cmds() {
  for cmd in "${sysz_cmds[@]}"; do
    _sysz_debug "checking cmd=$cmd"
    systemctl --help | grep UNIT | awk '{print $1}' | grep -q "$cmd" || {
      _sysz_error "Invalid systemctl command: $cmd"
      _sysz_quit 1
    }
  done
}

function _sysz_main() {

  # main
  _sysz_debug "fzf version=$(fzf --version)"

  # check fzf version
  if [[ "$(printf '%s\n' "$MIN_FZF_VERSION" "$(fzf --version | cut -d' ' -f1)" | sort -V | head -n1)" != "$MIN_FZF_VERSION" ]]; then
    _sysz_error "fzf >= $MIN_FZF_VERSION required. https://github.com/junegunn/fzf#upgrading-fzf"
    _sysz_quit 1
  fi

  _sysz_debug "SYSZ_HISTORY=$SYSZ_HISTORY"
  mkdir -p "$(dirname "$SYSZ_HISTORY")"
  touch "$SYSZ_HISTORY" || _sysz_error "Unable to write to $SYSZ_HISTORY"

  # root does not have user units
  if [[ $EUID -eq 0 ]]; then
    sysz_managers=(system)
  else
    sysz_managers=(user system)
  fi

  # TODO: combine these into one loop
  while [[ -n $1 ]]; do
    case $1 in
    # options
    -u | --user)
      sysz_managers=(user)
      ;;
    --sys | --system)
      sysz_managers=(system)
      ;;
    --state=*)
      sysz_states+=("${1#--state=}")
      ;;
    -s | --state)
      sysz_states+=("$2")
      shift
      ;;
    --type=*)
      sysz_types+=("${1#--type=}")
      ;;
    -t | --type)
      sysz_types+=("$2")
      shift
      ;;
    --no-color)
      SYSZ_COLORS=0
      ;;
    -v | --version)
      echo "$sysz_prog" $sysz_version
      exit 0
      ;;
    --debug)
      SYSZ_DEBUG=true
      ;;
    -V | --verbose)
      SYSZ_VERBOSE=true
      ;;
    -h)
      _sysz_short_help
      exit 0
      ;;
    --help)
      _sysz_help
      exit 0
      ;;

    # commands
    _sysz*)
      "$@"
      _sysz_quit $?
      ;;
    h | help)
      _sysz_help
      exit 0
      ;;

    # short command names
    re)
      sysz_cmds=(restart)
      ;;
    s)
      sysz_cmds+=(status)
      ;;
    ed)
      sysz_cmds+=(edit)
      ;;
    en)
      sysz_cmds+=(enable)
      ;;
    d | dis)
      sysz_cmds+=(disable)
      ;;
    j)
      sysz_cmds+=(journal)
      ;;
    f)
      sysz_cmds+=(follow)
      ;;
    c)
      sysz_cmds+=(cat)
      ;;

    # systemctl args
    --)
      shift
      sysz_args=("$@")
      break
      ;;

    -*)
      _sysz_error "Unknown option: $1" >&2
      _sysz_short_help >&2
      exit 1
      ;;
    *)
      # assume the next argument is a command name
      sysz_cmds+=("$1")
      ;;
    esac
    shift
  done

  _sysz_debug "sysz_managers=(${sysz_managers[*]})"
  _sysz_debug "sysz_cmds=(${sysz_cmds[*]})"
  _sysz_debug "sysz_states=(${sysz_states[*]})"
  _sysz_debug "sysz_types=(${sysz_types[*]})"
  _sysz_check_states
  _sysz_check_types
  _sysz_check_cmds

  local -a picks
  local -a results
  local key
  while :; do
    _sysz_prompt_units | readarray -t picks

    # The first result from fzf is always the key
    key=${picks[0]}
    results=${picks[*]:1}

    _sysz_handle_key "$key" || break
  done

  _sysz_debug "results=${results[*]}"
  if [[ ${#results[@]} -eq 0 ]]; then
    _sysz_quit 1
  fi

  # results look like '[s] foo.service - description'
  for result in "${results[@]}"; do
    _sysz_debug "result=$result"
    # read the first 2 words and throw away the rest
    IFS=" " read -r -a words <<<"$result"
    # picks are of the form: [s] foo.service
    sysz_units+=("${words[0]} ${words[1]}")
  done

  while [[ ${#sysz_cmds[@]} -eq 0 ]]; do
    _sysz_prompt_cmds
  done
}

_sysz_debug "SYSZ_VERBOSE=$SYSZ_VERBOSE"
_sysz_debug "SYSZ_COLORS=$SYSZ_COLORS"

_sysz_main "$@"

_sysz_quit
