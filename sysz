#!/usr/bin/env bash

# shell options
#set -x
set -o pipefail
shopt -s lastpipe
shopt -s extglob

# constants
export SHELL=bash
MIN_FZF_VERSION=0.27.1
PROG=$(basename "$0")
SYSZ_VERSION=1.4.3

# colors
RESET=$'\e[0m'
RED=$'\e[31m'
GREEN=$'\e[32m'
YELLOW=$'\e[33m'
BLUE=$'\e[34m'
CYAN=$'\e[36m'

# environment variables
SYSZ_HISTORY=${SYSZ_HISTORY:-${XDG_CACHE_HOME:-~/.cache}/sysz/history}

# global variables
declare VERBOSE
declare DEBUG
declare -a MANAGERS
declare -a STATES
declare -a TYPES

_sysz_keys() {
  cat <<EOF
Keybindings:
  TAB           Toggle selection.
  ctrl-r        Run daemon-reload. Selection is reset.
  ctrl-x        Switch between user or system managers. Selection is reset.
  ctrl-s        Select states to match. Selection is reset.
  ctrl-t        Select types to match. Selection is reset.
  ctrl-v        'cat' the unit in the preview window.
  ctrl-p        History previous.
  ctrl-n        History next.
  ?             Show keybindings.
EOF
}

_sysz_help() {
  cat >&2 <<EOF
A utility for using systemctl interactively via fzf.

Usage: $PROG [OPTS...] [CMD] [-- ARGS...]

sudo is invoked automatically, if necessary.

If only one unit is chosen, available commands will be presented
based on the state of the unit (e.g. "start" only shows if unit is "active").

OPTS:
  -u, --user               Only show --user units
  --sys, --system          Only show --system units
  -s STATE, --state STATE  Only show units in STATE (repeatable)
  -t TYPE, --type TYPE     Only show units of TYPE (repeatable)
  -V, --verbose            Print the systemctl command
  -v, --version            Print the version
  -h, --help               Print this message

  If no options are given, both system and user units are shown.

CMD:
  start                  systemctl start <unit>
  stop                   systemctl stop <unit>
  r, restart             systemctl restart <unit>
  s, stat, status        systemctl status <unit>
  ed, edit               systemctl edit <unit>
  reload                 systemctl reload <unit>
  en, enable             systemctl enable <unit>
  d, dis, disable        systemctl disable <unit>
  c, cat                 systemctl cat <unit>

  If no command is given, one or more can be chosen interactively.

ARGS are passed to the systemctl command for each selected unit.

$(_sysz_keys)

Environment Variables:
  SYSZ_HISTORY           Command history (default: $SYSZ_HISTORY)
  SYSZ_COLORS            Use colors (default: on)

Some units are colored based on state:
  green       active
  red         failed
  yellow      not-found
  template    blue
  other       cyan

Examples:
  $PROG -u                        User units
  $PROG --sys -s active           Active system units
  $PROG --user --state failed     Failed user units
  $PROG --type socket             Sockets
  $PROG -s inactive -t service    Inactive services

Examples with commands:
  $PROG start                     Start a unit
  $PROG --sys s                   Get the status of system units
  $PROG --user edit               Edit user units
  $PROG s -- -n100                Show status with 100 log lines
  $PROG --sys -s active stop      Stop an active system unit
  $PROG -u --state failed r       Restart failed user units
EOF

  exit 0
}

_sysz_quit() {
  [[ $DEBUG = true ]] && cat sysz.debug >&2
  exit "$1"
}

_sysz_error() {
  echo "ERROR: $*" >&2
  _sysz_quit 1
}

_sysz_debug() {
  [[ $DEBUG = true ]] && echo "$(date -Isec) $*" >>sysz.debug
}
_sysz_run() {
  _sysz_debug "> $*"
  "$@" || _sysz_error "Failed: $*"
}

_sysz_ctl() {
  _sysz_debug "> systemctl $*"
  systemctl "$@"
}

_sysz_verbose() {
  [[ $VERBOSE = true ]] && echo '>' "$@" >&2
  _sysz_run "$@"
}

_sysz_systemctl() {
  if [[ $EUID -ne 0 && $1 = --system ]]; then
    # only run sudo if we aren't root and it's a system unit
    _sysz_verbose sudo systemctl "$@"
  else
    [[ $VERBOSE = true ]] && echo systemctl "$@"
    _sysz_verbose systemctl "$@"
  fi
}

_sysz_journalctl() {
  if [[ $1 = --user ]]; then
    # use --user-unit flag if it's a user unit
    _sysz_verbose journalctl --user-unit="$2" "${@:3}"
  else
    if [[ $EUID -ne 0 ]]; then
      # only run sudo if we aren't root
      _sysz_verbose sudo journalctl --unit="$2" "${@:3}"
    else
      _sysz_verbose journalctl --unit="$2" "${@:3}"
    fi
  fi

}

_sysz_mgr() {
  case ${1%% *} in
  '[u'* | user* | --user*)
    echo --user
    ;;
  '[s'* | system* | --system*)
    echo --system
    ;;
  *)
    _sysz_error "Unknown manager: $1"
    ;;
  esac
}

_fzf_cat() {
  SYSTEMD_COLORS=1 _sysz_ctl "$(_sysz_mgr "$1")" cat -- "$2"
}

_fzf_preview() {
  local unit
  local args
  local mgr
  IFS=" " read -r -a args <<<"$1"
  mgr=$(_sysz_mgr "${args[0]}")
  unit=${args[1]}

  if [[ $unit = *@.* ]]; then
    _fzf_cat "${args[@]}"
  else
    SYSTEMD_COLORS=1 _sysz_ctl "$mgr" status --no-pager -- "$unit"
  fi
}

_sysz_show() {
  _sysz_ctl "$(_sysz_mgr "$1")" show "${1##* }" -p "$2" --value
}

_sysz_color_line() {
  local color
  color=$1
  sed -Ee 's,^(\[[us]\] )?([^ ]+) [^ ]+ [^ ]+( [^ ]+)?( .*)?$,\1'"$color"'\2'"$RESET"'\4,'
}

_sysz_ls() {
  local color
  local state
  local filter

  color=$CYAN
  filter=DO_NOT_MATCH
  for arg in "$@"; do
    case $arg in
    --filter=*)
      filter=${arg#--filter=} # strip --filter=
      shift
      ;;
    --state=active)
      color=$GREEN
      ;;
    --state=not-found)
      color=$YELLOW
      ;;
    --state=failed)
      color=$RED
      ;;
    '*@.*')
      color=$BLUE
      ;;
    esac
  done

  for mgr in "${MANAGERS[@]}"; do
    _sysz_ctl "$(_sysz_mgr "$mgr")" \
      --legend=false \
      --full \
      --plain \
      --no-pager \
      --all \
      "$@" |
      grep -Ev '^\S+\s+(\S+\s+)?('"$filter"')' |
      sed -Ee 's/ +/ /g;' |
      _sysz_color_line "$color" |
      sed -e "s/^/[${mgr:0:1}] /"
  done
}

_sysz_units() {
  if [[ ${#STATES[@]} -gt 0 && ${#TYPES[@]} -gt 0 ]]; then
    for cmd in list-units list-unit-files; do
      for state in "${STATES[@]}"; do
        for unit_type in "${TYPES[@]}"; do
          _sysz_ls "$cmd" "--state=$state" "--type=$unit_type"
        done
      done
    done

  elif [[ ${#STATES[@]} -gt 0 ]]; then
    for cmd in list-units list-unit-files; do
      for state in "${STATES[@]}"; do
        for unit_type in service timer; do
          _sysz_ls "$cmd" "--state=$state" "--type=$unit_type"
        done
        _sysz_ls "$cmd" "--state=$state" |
          grep -Ev '^\[\S+\] \S+(\.service|\.timer)'
      done
    done

  elif [[ ${#TYPES[@]} -gt 0 ]]; then
    for unit_type in "${TYPES[@]}"; do
      for state in failed active not-found; do
        _sysz_ls list-units "--state=$state" "--type=$unit_type"
      done
      _sysz_ls "--filter=failed|active|not-found" list-units "--type=$unit_type"
    done

  else
    # failed service
    # failed timer
    # failed units
    # active service
    # active timer
    # active units
    # not-found
    # remaining service
    # remaining timer
    # remaining
    # templates
    for state in failed active; do
      # show all failed and active services and timers first
      _sysz_ls list-units "--state=$state" --type=service
      _sysz_ls list-units "--state=$state" --type=timer
      # show remaining failed and active units
      _sysz_ls list-units "--state=$state" |
        grep -Ev '^\[\S+\] \S+(\.service|\.timer)'
    done
    # show all not-found units
    _sysz_ls list-units --state=not-found
    # show remaining services
    _sysz_ls '--filter=failed|active|not-found' list-units --type=service
    # show remaining timers
    _sysz_ls '--filter=failed|active|not-found' list-units --type=timer
    # show all remaining units
    _sysz_ls '--filter=failed|active|not-found' list-units |
      grep -Ev '^\[\S+\] \S+(\.service|\.timer)'
    # show all templates
    _sysz_ls list-unit-files '*@.*'
  fi
}

# main

# check fzf version
if [[ "$(printf '%s\n' "$MIN_FZF_VERSION" "$(fzf --version | cut -d' ' -f1)" | sort -V | head -n1)" != "$MIN_FZF_VERSION" ]]; then
  _sysz_error "fzf >= $MIN_FZF_VERSION required. https://github.com/junegunn/fzf#upgrading-fzf"
fi

_sysz_debug "fzf version: $(fzf --version)"

# root does not have user units
if [[ $EUID -eq 0 ]]; then
  MANAGERS=(system)
else
  MANAGERS=(user system)
fi

while [[ -n $1 ]]; do
  case $1 in
  -u | --user)
    MANAGERS=(user)
    shift
    ;;
  --sys | --system)
    MANAGERS=(system)
    shift
    ;;
  -s | --state)
    STATES+=("$2")
    shift
    shift
    ;;
  --state=*)
    STATES+=("${1#--state=}")
    shift
    ;;
  -t | --type)
    TYPES+=("$2")
    shift
    shift
    ;;
  --type=*)
    TYPES+=("${1#--type=}")
    shift
    ;;
  -v | --version)
    echo "$PROG" $SYSZ_VERSION
    exit 0
    ;;
  --debug)
    DEBUG=true
    shift
    ;;
  -V | --verbose)
    VERBOSE=true
    shift
    ;;
  -h | --help)
    _sysz_help
    ;;
  *)
    break
    ;;
  esac
done

_sysz_debug "MANAGERS=(${MANAGERS[*]})"
_sysz_debug "STATES=(${STATES[*]})"
_sysz_debug "TYPES=(${TYPES[*]})"
_sysz_debug "VERBOSE=$VERBOSE"

_sysz_check_states() {
  for state in "${STATES[@]}"; do
    if [[ -n $state ]] && ! systemctl --state=help | grep -v : | grep -q "^${state}$"; then
      _sysz_error "Invalid state: $state"
    fi
  done
}

_sysz_check_types() {
  for unit_type in "${TYPES[@]}"; do
    if [[ -n $unit_type ]] && ! systemctl --type=help | tail -n +2 | grep -q "^${unit_type}$"; then
      _sysz_error "Invalid type: $unit_type"
    fi
  done
}

_sysz_check_states
_sysz_check_types

while [[ -n $1 ]]; do
  case $1 in
  _fzf_preview)
    shift
    _fzf_preview "$@"
    exit 0
    ;;
  _fzf_cat)
    shift
    _fzf_cat "$@"
    exit 0
    ;;
  _sysz_units)
    _sysz_units
    exit 0
    ;;
  h | help)
    _sysz_help
    ;;
  # Handle short names
  re)
    cmd=restart
    ;;
  s)
    cmd=status
    ;;
  ed)
    cmd=edit
    ;;
  en)
    cmd=enable
    ;;
  d | dis)
    cmd=disable
    ;;
  j)
    cmd=journal
    ;;
  f)
    cmd=follow
    ;;
  c)
    cmd="cat"
    ;;
  --)
    shift
    args=("$@")
    break
    ;;
  -*)
    _sysz_error "Unknown option: $1"
    ;;
  *)
    # assume the next argument is a command name
    cmd=$1
    ;;
  esac
  shift
done

_sysz_debug "cmd=$cmd"
_sysz_debug "SYSZ_HISTORY=$SYSZ_HISTORY"

mkdir -p "$(dirname "$SYSZ_HISTORY")"
touch "$SYSZ_HISTORY"

function join_by {
  # https://stackoverflow.com/a/17841619/334632
  local d=${1-} f=${2-}
  if shift 2; then
    printf %s "$f" "${@/#/$d}"
  fi
}

_sysz_mgr_prompt() {
  if [[ $EUID -eq 0 ]]; then
    echo system
    return
  fi

  (
    echo user
    echo system
  ) |
    fzf \
      --multi \
      --no-info \
      --prompt="Manager: " |
    readarray -t MANAGERS || _sysz_quit $?

  _sysz_debug "Managers: ${MANAGERS[*]}"
}

_sysz_daemon_reload_prompt() {
  local managers
  (
    if [[ $EUID -ne 0 ]]; then
      echo 'user'
    fi
    echo 'system'
  ) |
    fzf \
      --multi \
      --no-info \
      --prompt="daemon-reload: " |
    readarray -t managers || _sysz_quit $?

  _sysz_debug "daemon-reload: ${managers[*]}"

  for mgr in "${managers[@]}"; do
    _sysz_systemctl "--$mgr" daemon-reload >&2
  done
}

_sysz_states_prompt() {
  local picked
  # hide 'ing' because they are transient states
  # which people probably aren't looking for
  prefered=(
    failed
    active
    inactive
    masked
    not-found
    enabled
    disabled
    exited
    bad
    error
  )
  (
    echo '(all)'
    printf '%s\n' "${prefered[@]}"
    systemctl --state=help |
      grep -v ':' |
      grep -v 'ing' |
      grep -Ev "^$(
        printf '%s|' "${prefered[@]:0:${#prefered[@]}-1}"
        echo "${prefered[*]: -1}"
      )$" |
      sort -u |
      grep -v '^$'
  ) |
    fzf \
      --multi \
      --no-sort \
      --prompt="States: " |
    readarray -t picked || _sysz_quit $?

  _sysz_debug "States: ${picked[*]}"

  STATES=()
  for state in "${picked[@]}"; do
    if [[ $state = '(all)' ]]; then
      STATES=()
      return
    fi
    STATES+=("$state")
  done
  _sysz_check_states
}

_sysz_types_prompt() {
  local picked
  (
    echo '(all)'
    echo service
    echo timer
    systemctl --type=help |
      grep -v ':' |
      grep -Ev '(service|timer)' |
      sort -u |
      grep -v '^$'
  ) |
    fzf \
      --multi \
      --no-sort \
      --prompt="Types: " |
    readarray -t picked || _sysz_quit $?

  _sysz_debug "Types: ${picked[*]}"

  TYPES=()
  for type in "${picked[@]}"; do
    if [[ $type = '(all)' ]]; then
      TYPES=()
      return
    fi
    TYPES+=("$type")
  done
  _sysz_check_types
}

declare key
declare cmd
declare multi
declare -a picks
declare -a cmds
declare -a args

while :; do
  picks=()
  key=

  # prompt units
  _sysz_units |
    fzf \
      --multi \
      --ansi \
      --expect=ctrl-r,ctrl-s,ctrl-x,ctrl-t \
      --history="$SYSZ_HISTORY" \
      --prompt="Units: " \
      --header '? for keybindings' \
      --bind "?:preview(echo '$(_sysz_keys)')" \
      --bind "ctrl-v:preview('${BASH_SOURCE[0]}' _fzf_cat {})" \
      --preview="'${BASH_SOURCE[0]}' _fzf_preview {}" \
      --preview-window=60% |
    readarray -t results || _sysz_quit $?

  # The first result from fzf is always the key
  key=${results[0]}
  _sysz_debug "key: $key"

  # results are of the form: [s] foo.service This is a description
  for result in "${results[@]:1}"; do
    _sysz_debug "RESULT: $result"
    IFS=" " read -r -a words <<<"$result"
    # picks are of the form: [s] foo.service
    picks+=("${words[@]:0:2}")
  done

  _sysz_debug "picks: ${picks[*]}"

  case $key in
  ctrl-r)
    _sysz_daemon_reload_prompt
    continue
    ;;
  ctrl-t)
    _sysz_types_prompt
    continue
    ;;
  ctrl-s)
    _sysz_states_prompt
    continue
    ;;
  ctrl-x)
    _sysz_mgr_prompt
    continue
    ;;
  esac

  if [[ ${#picks[@]} -eq 0 ]]; then
    _sysz_quit 1
  fi

  break

done

if [[ -n $cmd ]]; then
  cmds=("$cmd")
else

  if [[ ${#picks[@]} -gt 1 ]]; then
    printf -v preview '%s\n' "${picks[@]}"
    preview_cmd="echo -n '$preview'"
    multi=true
  else
    pick=${picks[0]}
    _sysz_debug "pick: $pick"

    # Handle template units
    if [[ $pick = *@.* ]]; then
      read -r -p "$pick requires a parameter: " param ||
        if [[ -z $param ]]; then
          _sysz_error "$pick requires a parameter"
        fi

      pick=${pick/\@/\@${param}}
      picks[0]=$pick
    fi

    # Get states to filter the command options
    active_state=$(_sysz_show "$pick" ActiveState)
    load_state=$(_sysz_show "$pick" LoadState)
    unit_file_state=$(_sysz_show "$pick" UnitFileState)
    can_reload=$(_sysz_show "$pick" CanReload)
    preview_cmd="'${BASH_SOURCE[0]}' _fzf_preview '$pick'"
  fi

  # prompt commands
  fzf \
    --multi \
    --ansi \
    --no-info \
    --no-sort \
    --prompt="Commands: " \
    --preview="$preview_cmd" \
    --preview-window=80% < <(
      # status
      echo status "${args[*]}"
      # restart
      [[ $multi = true || $active_state = active ]] &&
        printf '\033[0;31m%s\033[0m %s\n' restart "${args[*]}" # red
      # start
      [[ $multi = true || $active_state != active ]] &&
        printf '\033[0;32m%s\033[0m %s\n' start "${args[*]}" # green
      # stop
      [[ $multi = true || $active_state = active ]] &&
        printf '\033[0;31m%s\033[0m %s\n' stop "${args[*]}" # red
      # enable
      [[ $multi = true || $unit_file_state != enabled ]] &&
        {
          printf '\033[0;32m%s\033[0m %s\n' "enable" "${args[*]}" # green
          printf '\033[0;32m%s\033[0m %s\n' "enable" "--now ${args[*]}"
        }
      # disable
      [[ $multi = true || $unit_file_state = enabled ]] &&
        {
          printf '\033[0;31m%s\033[0m %s\n' disable "${args[*]}" # red
          printf '\033[0;31m%s\033[0m %s\n' disable "--now ${args[*]}"
        }

      # journal
      echo journal "${args[*]}"
      echo follow "${args[*]}"

      # reload
      [[ $multi = true || $can_reload = yes ]] &&
        printf '\033[0;37m%s\033[0m %s\n' reload "${args[*]}" # green

      # mask
      [[ $multi = true || ($unit_file_state != masked && $load_state != masked) ]] &&
        printf '\033[0;31m%s\033[0m %s\n' mask "${args[*]}" # red
      [[ $multi = true || $unit_file_state = masked || $load_state = masked ]] &&
        printf '\033[0;32m%s\033[0m %s\n' unmask "${args[*]}" # green

      # cat
      echo cat "${args[*]}"
      # edit
      echo edit "${args[*]}"
      # show
      echo show "${args[*]}"
    ) |
    readarray -t cmds || _sysz_quit $?
fi
_sysz_debug "cmds: ${cmds[*]}"

if [[ ${#cmds[@]} -eq 0 ]]; then
  _sysz_quit 1
fi

for pick in "${picks[@]}"; do

  mgr=$(_sysz_mgr "$pick")
  pick=${pick##* }

  for cmd in "${cmds[@]}"; do
    case ${cmd%% *} in
    journal)
      _sysz_journalctl "$mgr" "$pick" -xe "${args[@]}"
      _sysz_quit $?
      ;;
    follow)
      _sysz_journalctl "$mgr" "$pick" -xef "${args[@]}"
      _sysz_quit $?
      ;;
    status)
      # shellcheck disable=2086
      SYSTEMD_COLORS=1 _sysz_systemctl "$mgr" $cmd --no-pager "${args[@]}" -- "$pick"
      _sysz_quit $?
      ;;
    cat | show)
      _sysz_systemctl "$mgr" "$cmd" "${args[@]}" -- "$pick"
      _sysz_quit $?
      ;;
    *)
      # shellcheck disable=2086
      _sysz_systemctl "$mgr" $cmd "${args[@]}" -- "$pick"
      code=$?
      SYSTEMD_COLORS=1 _sysz_systemctl "$mgr" status --no-pager -- "$pick"
      if [[ ${#picks[@]} -eq 1 ]]; then
        _sysz_quit "$code"
      fi
      ;;
    esac
  done
done
